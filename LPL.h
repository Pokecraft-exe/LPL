#pragma once
#include "LPL_result.h"
#include "property.h"
#include <iostream>
#include <fstream>
#include <exception>
#include <sstream>

std::string slurp(std::ifstream& in) {
	std::ostringstream sstr;
	sstr << in.rdbuf();
	return sstr.str();
}

std::string ReplaceAll(std::string str, const std::string& from, const std::string& to) {
	size_t start_pos = 0;
	while ((start_pos = str.find(from, start_pos)) != std::string::npos) {
		str.replace(start_pos, from.length(), to);
		start_pos += to.length(); // Handles case where 'to' is a substring of 'from'
	}
	return str;
}

class LPL {
public:
	std::ifstream file;
	vector<string> schemes = {};
	map<string, vector<property>> properties = {};
	map<string, vector<string>> definitions = {};
	map<string, string> patterns = {};
private:
	void loadProperties() {
		string line = "";
		bool schemeStarted = false;
		bool patternStarted = false;
		string currentScheme = "";

		while (!file.eof()) {
			std::getline(file, line);
			if (line.find("//", 0) == string::npos) {
				if (line[0] == '(') {
					currentScheme = line.substr(1, line.size());
					schemeStarted = true;
					properties[currentScheme] = vector<property>();
					schemes.push_back(line.substr(1, line.size()));
				}
				if (schemeStarted && !patternStarted) {
					if (line[0] == '"') {
						string currentProperty = line.substr(1, line.size() - 2);
						properties[currentScheme].push_back(currentProperty);
					}
					else if (line.find("map(") != string::npos) {
						int posStart = line.find('\"') + 1;
						int posEnd = line.rfind("\"") - posStart;
						property currentProperty(line.substr(posStart, posEnd), functions::map, {});
						properties[currentScheme].push_back(currentProperty);
					}
					else if (line.find("list(") != string::npos) {
						int posStart = line.find('\"') + 1;
						int posEnd = line.rfind("\"") - posStart;
						int posArgStart = line.find("\'") + 1;
						int posArgEnd = line.rfind("\'") - posArgStart;
						property currentProperty(line.substr(posStart, posEnd), functions::list, { line.substr(posArgStart, posArgEnd) });
						properties[currentScheme].push_back(currentProperty);
					}
					else if (line.find("ref(") != string::npos) {
						int posStart = line.find('\"') + 1;
						int posEnd = line.rfind("\"") - posStart;
						int posArgStart = line.find('\'') + 1;
						int posArgEnd = line.rfind('\'') - posArgStart;
						property currentProperty(line.substr(posStart, posEnd), functions::ref, { line.substr(posArgStart, posArgEnd) });
						properties[currentScheme].push_back(currentProperty);
					}
				}
				if (line[0] == ')') {
					schemeStarted = false;
					patternStarted = false;
				}
				if (patternStarted) {
					patterns[currentScheme] += "\"" + ReplaceAll(line, "\"", "\\\"") + "\"";
				}
				if (schemeStarted && line[0] == '=' && line[1] == '=') {
					patternStarted = true;
				}
			}
		}
	}
	std::string identify(std::string scheme) {
		std::ifstream src("Source.txt");
		std::string func = slurp(src);
		func = ReplaceAll(func, "%s", scheme);
		return ;
	}

public:
	bool loadScript(string fileToRead) {
		file = std::ifstream(fileToRead);
		if (file.good()) {
			loadProperties();
			return true;
		}
		else {
			throw std::invalid_argument("file can't open");
			return false;
		}
	}

	void compileAll() {
		for (std::string s : schemes) {
			compileScheme(s);
		}
	}
	void compileScheme(string scheme) {
		string header = "\
@pragma once\n\
#include <string>\n\
#include <vector>\n\
#include <map>\n\
#include \"LPL.h\"\n\
  /**********************************/\n\
 /* Code generated by LPL compiler */\n\
/**********************************/\n\
std::vector<std::string> LPLtokenize(std::string str, bool pushSpace = true);\n\
std::vector<std::vector<std::string>> LPLtokenize(std::vector<std::string> str);\n";

		string code = "";
		code += "struct " + scheme + "{tstatic std::string pattern;\n";
		for (auto pp : properties[scheme]) {
			code += pp.compile();
		}
		code += "\t" + scheme + "(){}\n";
		code += "\t void push(std::string parameter, string __value);\n";

		code += "\tusing identification_result = struct __result__{\n\
\t\tvariable * result;\n\
\t\tbool success;\n\
\t\t__result__() {};\n\
\t};\n";

		code += "\tstatic identification_result identify(string::iterator begin, string::iterator end);\n";
		code += "};\n";

		std::ofstream headerFile("LPL_" + scheme + ".h");
		
		headerFile << header + code;

		headerFile.close();

		std::ofstream codeFile("LPL_" + scheme + ".cpp");

		codeFile << "#include \"LPL_"+scheme+".h\"\n  /**********************************/\n/* Code generated by LPL compiler */\n/**********************************/\n";

		codeFile << "std::string " + scheme + "::pattern = " + patterns[scheme] + ";\n";
		codeFile << "void "+scheme+"::push(std::string parameter, string __value) {\n";
			
		for (auto& p : properties[scheme]) {
			if (p.name().find("(") == std::string::npos)
				codeFile << "\tif (parameter == \"" + p.name() + "\") " + p.name() + " = __value;\n";
		}

		codeFile << "}\n";

		codeFile << "identification_result identify(string::iterator begin, string::iterator end) {\n" << identify(scheme) << std::endl;

		codeFile.close();
	}
	
};